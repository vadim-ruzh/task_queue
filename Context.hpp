// FORMAT: В инклуд гарде дубляж TASK QUEUE
#ifndef TASK_QUEUE_TASKQUEUE_HPP
#define TASK_QUEUE_TASKQUEUE_HPP

#include <thread>
#include <future>
#include <queue>

// TODO: все функции, что бросают исключения должны быть помечены как noexcept(false), 
// 												а те, что не бросают - noexcept
class Context
{
public:
	using Task = std::packaged_task<bool()>;

	class Work;
	class Strand;

	Context();
	~Context();

	// TODO: Такая архитектура позволяет вернуть bool, но, правда, непонятно зачем. 
	// 		Точнее это какой-то корнер кейс, и уж лучше вообще ничего не возвращать, чем bool, который непонятно зачем нужен вызывающей стороне.
	//		В примерах из main даже видно, что приходится возращать фиктивные единицы.
	// В связи с этим у нас есть много вариантов как поступить, в т.ч. переписать архитектуру на future-ы от void, 
	//		тем самым не парясь за возвращаемые значения и перекладывая это на юзера 
	//			(пусть мол в функторе сам реализует возврат, передавай в функтор ссылки). 
	//		Но это очень долго, и на самом деле непонятно насколько нужно.
	// 		Поэтому лучше всего тогда сделать вместо bool коды возврата для обработки ошибок, как мы уже делали в логере. Таким образом появится больше смысла от возвращаемого значения. 
	//		Понятно что future может обрабатывать исключения, но передача исключения из одного потока в другой - дорогостоящая операция. 
	//			Поэтому лучше оставить поддержку выброса исключений как фичу, которую рекомендовать не использовать. Вместо этого рекомендовать юзать коды возврата.
	std::future<bool> Post(std::function<bool()>&& func);

	// NAMING: Run - Stop, не совсем антонимы. Start - Stop звучат получше, потому что антонимы. Но не прнципиально, можно не править.
	void Run();

	void Stop();

	// QUESTION: Насколько вероятно, что юзеру понадобится такой метод? 
	// QUESTION: Реализация метода делает mStop.exchange(false), что с моей точки зрения не выглядит как рестарт. Ч
	//				то же делает этот метод на самом деле?
	void Restart();
private:
	std::queue<Task> mTasks;
	std::mutex mMutex;
	// FORMAT: поехал кодстайл, ниже mIsWork, а mStop почему-то без предлога Is.
	std::atomic_bool mStop;
	// NAMING: поехал перевод, на данный момент непонятно какое время: 
	// Глагол в форме инфинитива указывает на Simple время, но почему-то перед ним стоит Is, который намекает на Continious время.
	// Лучше бы уж тогда юзать Continious, и добавить ing-овое окончание глаголу: mIsWorking.
	std::atomic_bool mIsWork;
	// NAMING: непонятное название. моёСостояние - состояние чего? 
	// По названию должно быть понятно зачем используется переменная.
	std::condition_variable myCondition;
};

class Context::Work
{
public:
	explicit Work(Context& context);
	~Work();
private:
	// FORMAT: снова поехал кодстайл, выше юзаешь mStop, а тут уже m_context через нижнее подчёркивание.
	// Кодстайл - это серьёзно, потому что когда тебя будут ревьюить на задании к стажировке 
	//		по прыгающему кодстайлу им сразу станет понятно, что ты начинающий. 
	//		Поэтому прижерживайся одного стиля кода, так впечатление от кода станет лучше.
	Context& m_context;
};

// TODO: мёртвый код? Не нашёл реализации стренда.
class Context::Strand
{
 public:
	explicit Strand(Context& context);
	~Strand();

 private:

};


#endif //TASK_QUEUE_TASKQUEUE_HPP

